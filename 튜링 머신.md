# 튜링 머신

# 1. 튜링 머신

"상태" 를 가지고 있으며, 그 "상태"에 의거하여 "명령들"에서 "명령"을 한 개씩 뽑아 실행하여 자신의 "상태"에 반영하는 기계를 생각합시다.

# 2. CPU 실행 원리

옛날의 초간단 CPU는 음

이건 전기전자랑도 겹칠텐데 

RISC를 먼저 배워 봅시다!

네!

```c
while(true) {
	instruction = memory[pc];
	do_instruction;
	pc += sizeof one instruction;
}
```

CPU는 이 과정을 무한히 반복합니다.

memory를 할일 리스트를 적어놓은 종이,

instruction을 할 일 하나,

pc는 다음에 읽을 instruction을 가리키는 손가락이라 합시다. 

혹시 도덕 시간이라던가,

> 먼저 문제를 끝까지 읽으세요. 
이 종이에 자기 이름을 쓰세요.
나는 멍청이다. 라고 세번 외치세요.
코끼리 코를 하고 10번 도세요.
친구와 가위바위보를 해서 이기세요.
내가 1등이다 라고 외치세요.
자 여기까지 다 읽었으면 1~2번만 하고 손을 드세요.

 이런 거 해본 적 있나요?

네! 

저 종이가 instruction들이 잔뜩 적혀있는 memory, 이 종이를 읽기 위해 손가락으로 가리키며 읽었다면 손가락을 pc라 하면 됩니다.

중간에 문제 번호 4로 돌아가세요. 이러면 pc에다 4를 넣으란 소리로 생각하면 됩니다.

이해가 되나요? 네 이해했습니다. 

다음 문제를 읽기 위해 손가락을 아래로 한 칸씩 이동하면서 읽었다고 합시다.

 자 그럼 진짜 CPU 돌아가는 모양을 봅시다

전기전자 회로에서 ADD 논리회로 배웠나요? 그 NOT, AND, OR 로 표현하는 ADD 회로?

그거는 저번 학기 때 혼자 만들어봤었어요

좋습니다

위에서 손가락을 1 칸씩 아래로 이동하는 것은 CPU에서는 PC에 인스트럭션 크기만큼 더하는 것을 의미합니다.

저 종이에서는 인스트럭션 하나의 크기는 1줄이었으므로 손가락이 1줄이 내려갔었습니다. 만약에 인스트럭션이 너무 길어서 2줄이었다면 손가락이 2줄 내려갔었겠죠?

맞습니다. 

CPU에서도 똑같은 일이 일어납니다. 어떤 인스트럭션을 읽고 나면 손가락의 위치(PC)가 해당 인스트럭션 크기만큼 증가합니다. 이거는 보통 ADD 회로가 담당합니다.

그럼 만약 바로 다음 인스트럭션이 아닌 다음 다음 인스트럭션으로 가고 싶으면 따로 설정을 해주어야 하는 건가요?

네 그게 바로 JMP 인스트럭션입니다. 여기서 PC relative addressing이 살짝 나옵니다.

PC에 어떤 값을 더해서 PC를 변형시키는 회로를 만들어 놓았는데, 현재는 방금 읽은 인스트럭션의 크기만큼만 더하게 해놓았었습니다.
만약 다음다음 인스트럭션으로 바로 가게 하고 싶다면, 이 PC ADD 회로에 다음다음인스트럭션의 주소에서 현재 인스트럭션의 주소를 뺀 값, 즉 현재인스트럭션의 크기와 다음인스트럭션의 크기를 더한 값을 더하게 하면 되겠죠? 

> 그렇습니다. 그럼 각 인스트럭션의 크기를 저장하는 메모리 또한 따로 할당이 되어 있는 거죠?

만약에 지금 하던 일이 3번이고 10번으로 바로 점프하세요 하고 싶다면,
JMP 7 하면 되겠죠? (인스트럭션 1개당 1바이트라면)

네! JMP 7!

JMP 7은 결국은
ADD PC, 7과 같은 명령이라는 것입니다.
분명 10번으로 점프해라라는 명령인데 JMP 10이 아니라 JMP 7로 명령어가 생성된 것을 기억해 두세요. 

각 인스트럭션의 크기를 저장하는 메모리가 따로 할당되어 있다면, 인스트럭션 하나를 실행 할 때마다 그 인스트럭션의 크기를 알기 위해 메모리를 접근해야 하겠네요. 이것은 비효율적이기 때문에,
RISC(Reduced Instruction Set Computer)에서는 애초에 모든 명령어의 크기가 4바이트 또는 8바이트 등으로 정해져 있습니다.
CISC(Complex Instruction Set Computer)의 인스트럭션의 크기는 1바이트부터 7바이트 정도까지 다양한데, 이러한 크기는 CPU 설계를 엄청 멋있게 했는지 어떤진 모르겠지만 CPU가 알아서 몇 바이트 명령어인지 다 압니다.

오오 CISC

![%E1%84%90%E1%85%B2%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20ccdac04a46f64dac98f6f9db318d10b5/20200806_231314.jpg](%E1%84%90%E1%85%B2%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20ccdac04a46f64dac98f6f9db318d10b5/20200806_231314.jpg)

154번 그림이 바로 1클록마다 PC레지스터에 4씩 더해지는 회로의 모습입니다.

1클록이 지날 때마다 PC의 값이 4가 더해지고, 이에 따라 메모리 유닛에 요청하는 주소가 4씩 증가하고, 그 결과물인 인스트럭션이 매 클럭마다 계속 변하는 것이죠. 이해가 되나요?

네 !

![%E1%84%90%E1%85%B2%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20ccdac04a46f64dac98f6f9db318d10b5/20200806_231710.jpg](%E1%84%90%E1%85%B2%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20ccdac04a46f64dac98f6f9db318d10b5/20200806_231710.jpg)

160번 그림을 보면 인스트럭션 페치를 실행하는 회로가 나타나 있습니다. 인스트럭션 페치란 바로 메모리에서 인스트럭션을 하나 하나씩 읽어서 인스트럭션 레지스터에 넣는 것을 의미합니다. 레지스터는 CPU 전용 내부 변수라고 생각해 주세요. 사실은 SRAM같은 거로 되어 있습니다.

> CPU 내부의 메모리 역할이 레지스터인가보군요

맞아요

인스트럭션을 읽어야 인스트럭션을 실행할 수 있기 때문이에요

SRAM은 아

> 

[Register file](https://en.wikipedia.org/wiki/Register_file)

CPU 내부에서 사용하는 변수들은 사실 플립플롭 같은 거로 이루어져 있어요.

> 플립플롭이 뭔가요?

[플립플롭](https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD)